<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Gemini Voice Editor</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 16px;
      background: #f5f5f5;
    }

    .container {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .header {
      background: white;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    h1 {
      font-size: 18px;
      margin-bottom: 8px;
      color: #333;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ccc;
    }

    .status-indicator.connected {
      background: #4caf50;
      animation: pulse 2s infinite;
    }

    .status-indicator.error {
      background: #f44336;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .voice-section {
      background: white;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .voice-button {
      width: 100%;
      padding: 16px;
      font-size: 16px;
      font-weight: 600;
      color: white;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .voice-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .voice-button:active {
      transform: translateY(0);
    }

    .voice-button.recording {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      animation: recording-pulse 1.5s infinite;
    }

    @keyframes recording-pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(245, 87, 108, 0.7); }
      50% { box-shadow: 0 0 0 10px rgba(245, 87, 108, 0); }
    }

    .text-input-section {
      background: white;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .text-input {
      width: 100%;
      padding: 12px;
      font-size: 14px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      margin-bottom: 12px;
      font-family: inherit;
    }

    .text-input:focus {
      outline: none;
      border-color: #667eea;
    }

    .send-button {
      width: 100%;
      padding: 12px;
      font-size: 14px;
      font-weight: 600;
      color: white;
      background: #667eea;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }

    .send-button:hover {
      background: #5568d3;
    }

    .history {
      background: white;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      max-height: 200px;
      overflow-y: auto;
    }

    .history h3 {
      font-size: 14px;
      margin-bottom: 12px;
      color: #666;
    }

    .history-item {
      padding: 8px 12px;
      background: #f9f9f9;
      border-radius: 4px;
      margin-bottom: 8px;
      font-size: 13px;
    }

    .history-item.success {
      border-left: 3px solid #4caf50;
    }

    .history-item.error {
      border-left: 3px solid #f44336;
    }

    .suggestions {
      background: white;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .suggestions h3 {
      font-size: 14px;
      margin-bottom: 12px;
      color: #666;
    }

    .suggestion-chip {
      display: inline-block;
      padding: 6px 12px;
      margin: 4px;
      background: #e8eaf6;
      color: #667eea;
      border-radius: 16px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .suggestion-chip:hover {
      background: #667eea;
      color: white;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Gemini Voice Editor</h1>
      <div class="status">
        <div class="status-indicator" id="statusIndicator"></div>
        <span id="statusText">Disconnected</span>
      </div>
    </div>

    <div class="voice-section">
      <button class="voice-button" id="voiceButton">
        Hold to Speak
      </button>
    </div>

    <div class="text-input-section">
      <input
        type="text"
        class="text-input"
        id="textInput"
        placeholder="Or type a command here..."
      />
      <button class="send-button" id="sendButton">
        Send Command
      </button>
    </div>

    <div class="suggestions">
      <h3>Suggestions</h3>
      <div id="suggestionsContainer">
        <span class="suggestion-chip">Create a blue button</span>
        <span class="suggestion-chip">Make header larger</span>
        <span class="suggestion-chip">Change background to white</span>
      </div>
    </div>

    <div class="history">
      <h3>Command History</h3>
      <div id="historyContainer">
        <!-- History items will be added here -->
      </div>
    </div>
  </div>

  <script>
    const statusIndicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('statusText');
    const voiceButton = document.getElementById('voiceButton');
    const textInput = document.getElementById('textInput');
    const sendButton = document.getElementById('sendButton');
    const historyContainer = document.getElementById('historyContainer');
    const suggestionsContainer = document.getElementById('suggestionsContainer');

    let isRecording = false;
    let mediaRecorder = null;
    let audioChunks = [];
    let ws = null;

    // WebSocket connection
    function connectToServer() {
      try {
        ws = new WebSocket('ws://localhost:8080');

        ws.onopen = () => {
          console.log('Connected to server');
          updateStatus('connected');
        };

        ws.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            handleServerMessage(message);
          } catch (error) {
            console.error('Error parsing server message:', error);
          }
        };

        ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          updateStatus('error');
        };

        ws.onclose = () => {
          console.log('Disconnected from server');
          updateStatus('disconnected');
          // Attempt to reconnect after 3 seconds
          setTimeout(connectToServer, 3000);
        };
      } catch (error) {
        console.error('Error connecting to server:', error);
        updateStatus('error');
      }
    }

    // Handle messages from server
    function handleServerMessage(message) {
      console.log('Received from server:', message);

      // Forward execute-command messages to plugin code
      if (message.type === 'execute-command' || message.type === 'get-file-data') {
        parent.postMessage({
          pluginMessage: {
            type: 'server-message',
            data: message
          }
        }, '*');
      }
    }

    // Update connection status
    window.onmessage = async (event) => {
      const msg = event.data.pluginMessage;

      switch (msg.type) {
        case 'command-executed':
          addToHistory(msg);
          break;
        case 'send-to-server':
          // Forward message from plugin code to server
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(msg.data));
          }
          break;
        case 'file-context':
          // Received file context, now send the command with context
          if (window.pendingCommand && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              type: 'voice-command',
              data: {
                text: window.pendingCommand.text,
                context: msg.data
              }
            }));
            addToHistory({ success: true, command: { rawText: window.pendingCommand.text } });
            window.pendingCommand = null;
          }
          break;
      }
    };

    function updateStatus(status) {
      statusIndicator.className = 'status-indicator ' + status;
      statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
    }

    function addToHistory(result) {
      const item = document.createElement('div');
      item.className = 'history-item ' + (result.success ? 'success' : 'error');
      item.textContent = result.success
        ? `✓ ${result.command.rawText || 'Command executed'}`
        : `✗ ${result.error}`;
      historyContainer.insertBefore(item, historyContainer.firstChild);
    }

    // Voice recording
    voiceButton.addEventListener('mousedown', startRecording);
    voiceButton.addEventListener('mouseup', stopRecording);
    voiceButton.addEventListener('mouseleave', stopRecording);

    async function startRecording() {
      if (isRecording) return;

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          audioChunks.push(event.data);
        };

        mediaRecorder.onstop = async () => {
          const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
          const reader = new FileReader();
          reader.onloadend = () => {
            const base64Audio = reader.result.split(',')[1];
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'voice-command', data: { audio: base64Audio } }));
            } else {
              alert('Not connected to server. Please check that the server is running.');
            }
          };
          reader.readAsDataURL(audioBlob);
        };

        mediaRecorder.start();
        isRecording = true;
        voiceButton.classList.add('recording');
        voiceButton.textContent = 'Recording...';
      } catch (error) {
        console.error('Error accessing microphone:', error);
        alert('Could not access microphone. Please grant permission.');
      }
    }

    function stopRecording() {
      if (!isRecording || !mediaRecorder) return;

      mediaRecorder.stop();
      mediaRecorder.stream.getTracks().forEach(track => track.stop());
      isRecording = false;
      voiceButton.classList.remove('recording');
      voiceButton.textContent = 'Hold to Speak';
    }

    // Text input
    sendButton.addEventListener('click', sendTextCommand);
    textInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendTextCommand();
    });

    function sendTextCommand() {
      const text = textInput.value.trim();
      if (!text) return;

      if (ws && ws.readyState === WebSocket.OPEN) {
        // First, request file context from plugin
        parent.postMessage({
          pluginMessage: { type: 'get-file-context' }
        }, '*');

        // Store the command to send after receiving context
        window.pendingCommand = { text };
      } else {
        alert('Not connected to server. Please check that the server is running.');
      }

      textInput.value = '';
    }

    // Suggestion chips
    suggestionsContainer.addEventListener('click', (e) => {
      if (e.target.classList.contains('suggestion-chip')) {
        textInput.value = e.target.textContent;
      }
    });

    // Connect on load
    connectToServer();
  </script>
</body>
</html>
